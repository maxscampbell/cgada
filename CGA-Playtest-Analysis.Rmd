---
title: "Cash Grab Arena -- Playtest Data Analysis"
author: "Version 0.12.*"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)

# Load in relevant packages
library(ggplot2)
library(glue)
library(purrr)
library(tidyverse)
library(ggforce)
```

```{r echo=FALSE}
#Column names to fit to each dataset
varnames <- c("Class", "Entries", "Coins", "Kills", "Deaths", "Vigor.Flask.Entries", 
            "Bandage.Entries", "Accelerator.Entries", "Echo.Bolt.Entries",
            "Spring.Plume.Entries", "Hedge.Seed.Entries", "Risk.It.Biscuit.Entries",
            "Nox.Bomb.Entries", "Flame.Trap.Entries", "Lava.Cake.Entries", 
            "Smoke.Screen.Entries",
            "Vigor.Flask.Coins", "Bandage.Coins", "Accelerator.Coins", 
            "Echo.Bolt.Coins", "Spring.Plume.Coins", "Hedge.Seed.Coins",
            "Risk.It.Biscuit.Coins", "Nox.Bomb.Coins", "Flame.Trap.Coins", 
            "Lava.Cake.Coins", "Smoke.Screen.Coins"
            )

# Read in data and clean column names
setwd("data")

march16 <- read.csv("March 16 2025.csv", TRUE)
colnames(march16) <- varnames
march16 <- march16 |>
  mutate(Date = "03/16/2025",
         Version = "0.12.*")

march22 <- read.csv("March 22 2025.csv", TRUE)
colnames(march22) <- varnames
march22 <- march22 |>
  mutate(Date = "03/22/2025",
         Version = "0.12.*")

march30 <- read.csv("March 30 2025.csv", FALSE)
colnames(march30) <- varnames
march30 <- march30 |>
  mutate(Date = "03/30/2025",
         Version = "0.12.*")

april27 <- read.csv("April 27 2025.csv", FALSE)
colnames(april27) <- varnames
april27 <- april27 |>
  mutate(Date = "04/27/2025",
         Version = "0.12.*")

may11 <- read.csv("May 11 2025.csv", FALSE)
colnames(may11) <- varnames
may11 <- may11 |>
  mutate(Date = "05/11/2025",
         Version = "0.12.*")

june26 <- read.csv("June 26 2025.csv", FALSE)
colnames(june26) <- varnames
june26 <- june26 |>
  mutate(Date = "06/26/2025",
         Version = "0.12.*")

july6 <- read.csv("July 6 2025.csv", FALSE)
colnames(july6) <- varnames
july6 <- july6 |>
  mutate(Date = "07/06/2025",
         Version = "0.12.*")

july27 <- read.csv("July 27 2025.csv", FALSE)
colnames(july27) <- varnames
july27 <- july27 |>
  mutate(Date = "07/27/2025",
         Version = "0.12.*")

august31 <- read.csv("August 31 2025.csv", FALSE)
colnames(august31) <- varnames
august31 <- august31 |>
  mutate(Date = "08/31/2025",
         Version = "0.12.*")


#Merge obs. into one set of data
dflist <- list(march16, march22, march30, april27, may11, june26, july6, july27, august31)
suppressMessages(cgada <- march16 |>
  full_join(march22) |>
  full_join(march30) |>
  full_join(april27) |>
  full_join(may11) |>
  full_join(june26) |>
  full_join(july6) |>
  full_join(july27) |>
  full_join(august31) |>
  mutate(Entries.Total = sum(Entries)) |>
  group_by(Class) |>
  mutate(KPE = sum(Kills) / sum(Entries),
         CPE = sum(Coins) / sum(Entries),
         Entry.Percent = round(sum(Entries) / Entries.Total, 3)) |>
  ungroup() |>
  mutate(KPE.scaled = (KPE - (0.8 * min(KPE))) / ((1.2 * max(KPE)) - (0.8 * min(KPE))),
         CPE.scaled = (CPE - (0.8 * min(CPE))) / ((1.2 * max(CPE)) - (0.8 * min(CPE)))) |>
  mutate(Rel.Eff = KPE.scaled - CPE.scaled) |>
  group_by(Class))

#Compile all rate statistics into one dataframe
dflist <- list(distinct(cgada, Class), distinct(cgada, KPE), distinct(cgada, CPE), distinct(cgada, Entry.Percent), distinct(cgada, Rel.Eff))
rate <- purrr::reduce(.x = dflist, merge, by = 'Class')
```

# Class Data

## General Class Popularity

```{r echo=FALSE}
cgada.ungrouped <- cgada |>
  ungroup() |>
  mutate(KPE = Kills / Entries,
         CPE = Coins / Entries) |>
  group_by(Class) |>
  mutate(KPE.mean = mean(KPE, na.rm = TRUE),
         KPE.sd = sd(KPE, na.rm = TRUE),
         CPE.mean = mean(CPE, na.rm = TRUE),
         CPE.sd = sd(CPE, na.rm = TRUE))

#Std. Dev
EP.sigma <- sd(rate$Entry.Percent)

ggplot(rate, aes(x = Class, y = Entry.Percent)) +
  geom_bar(stat = "identity", color = "black", fill = "green") +
  theme(legend.position = "none") +
  xlab("Class") + ylab("% of Total Lives") +
  labs(title = "Class Popularity (% of Total Lives Played)",
       caption = glue("Std. Dev.: {round(EP.sigma, 3)}
                      Red line indicates expected popularity assuming classes are to be equally used.")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  geom_hline(yintercept = 1 / nrow(distinct(cgada, Class)), color = "red")
```

## Kills Per Entry

```{r echo=FALSE}

ggplot(cgada.ungrouped, aes(x = Class, y = KPE)) +
  geom_bar(stat = "summary", fun = "mean", color = "black", fill = "slateblue") +
  theme(legend.position = "none") +
  xlab("Class") + ylab("Kills") + ylim(0, 1.5) +
  labs(title = "Kills per Entry (within-Class Variance)",
       caption = glue("Red line indicates average across all classes.
                      Error bars indicate values which we could likely observe on repeated playtests, given current balancing.")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  geom_errorbar(ymin = cgada.ungrouped$KPE.mean - cgada.ungrouped$KPE.sd,
                ymax = cgada.ungrouped$KPE.mean + cgada.ungrouped$KPE.sd,
                width = 0.5) +
  geom_hline(yintercept = mean(cgada.ungrouped$KPE, na.rm = TRUE), color = "red")
```

## Coins Per Entry

```{r echo=FALSE}
ggplot(cgada.ungrouped, aes(x = Class, y = CPE)) +
  geom_bar(stat = "summary", fun = "mean", color = "black", fill = "gold") +
  theme(legend.position = "none") +
  xlab("Class") + ylab("Coins") + ylim(0, 60) +
  labs(title = "Average Coins per Entry (within-Class Variance)",
       caption = glue("Red line indicates average across all classes.
                      Error bars indicate values which we could likely observe on repeated playtests, given current balancing.")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  geom_errorbar(ymin = cgada.ungrouped$CPE.mean - cgada.ungrouped$CPE.sd,
                ymax = cgada.ungrouped$CPE.mean + cgada.ungrouped$CPE.sd,
                width = 0.5) +
  geom_hline(yintercept = mean(cgada.ungrouped$CPE, na.rm = TRUE), color = "red")
```

## Relative Efficiency

```{r echo=FALSE}
ggplot(rate, aes(x = Class, y = Rel.Eff,)) +
  geom_bar(stat = "identity", color = "black", fill = "red") +
  theme(legend.position = "none") +
  xlab("Class") + ylab("% Difference") +
  labs(title = "Relative Efficiency",
          subtitle = "Difference in scaled Kills per Entry and Coins per Entry",
          caption = glue("Positive values indicate more efficient kill generation per life.
          Negative values indicate more efficient coin earnings per life.
          Larger magnitudes suggest more extreme specializations.")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  geom_hline(yintercept = 0, color = "black")
```

Everyone thank Taylor for showing how coin-oriented Spectre can be :)

# Trinket Data

```{r results=FALSE, echo=FALSE}
Class <- rate$Class
Trinket <- c("Vigor Flask", "Bandage", "Accelerator", "Echo Bolt", "Spring Plume", "Hedge Seed", "Risk-it-Biscuit", "Nox Bomb", "Flame Trap", "Lava Cake", "Smoke Screen")
trinket.entries <- cgada[,c(6:16)]
trinket.coins <- cgada[,c(17:27)]

trinket.pop <- rep(NA, ncol(trinket.entries))
trinket.CPE <- rep(NA, ncol(trinket.coins))

#Sum up the values of each trinket and save to vectors
for (i in 1:ncol(trinket.entries)) {
  trinket.pop[i] <- sum(trinket.entries[,i])
  trinket.CPE[i] <- sum(trinket.coins[,i]) / trinket.pop[i]
}
tp <- trinket.pop / sum(cgada$Entries)
trinket.data <- data.frame(Trinket, trinket.pop, trinket.CPE, tp)

#Create the Class-and-Trinket ranking

grouped.trinket.entries <- cgada |>
  group_by(Class) |>
  summarise(vfsum = sum(Vigor.Flask.Entries),
            bsum = sum(Bandage.Entries),
            asum = sum(Accelerator.Entries),
            ebsum = sum(Echo.Bolt.Entries),
            spsum = sum(Spring.Plume.Entries),
            hssum = sum(Hedge.Seed.Entries),
            ribsum = sum(Risk.It.Biscuit.Entries),
            nbsum = sum(Nox.Bomb.Entries),
            ftsum = sum(Flame.Trap.Entries),
            lcsum = sum(Lava.Cake.Entries),
            sssum = sum(Smoke.Screen.Entries))

grouped.trinket.entries <- grouped.trinket.entries[,c(2:12)]

ct.string <- rep(NA, length(Class) * ncol(trinket.entries))
ct.count <- rep(NA, length(Class) * ncol(trinket.entries))
for (i in 1:length(Class)) {
  for (j in 1:ncol(trinket.entries)) {
    ct.string[(11 * i) - (11 - j)] <- glue("{Class[i]}/{Trinket[j]}")
    ct.count[(11 * i) - (11 - j)] <- grouped.trinket.entries[i,j]
  }
}
ct.count <- unlist(ct.count)
ct.rank <- data.frame(ct.string, ct.count)
ct.rank.sorted <- ct.rank[order(-ct.count),]
```

## Trinket Popularity

```{r echo=FALSE}
tp.sigma <- sd(trinket.data$tp)

ggplot(trinket.data, aes(x = Trinket, y = tp)) +
  geom_bar(stat = "identity", color = "black", fill = "orange") +
  theme(legend.position = "none") +
  xlab("Trinket") + ylab("% Entries") +
  labs(title = "Trinket Usage (% of Total Lives Played)",
  caption = glue("Std. Dev.: {round(tp.sigma, 3)}
                 Red line indicates expected usage for each trinket, assuming they are to be equally used.")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  geom_hline(yintercept = 1 / nrow(trinket.data), color = "red")
```

## Trinket Efficacy

```{r echo=FALSE}
tc.sigma <- sd(trinket.data$trinket.CPE)

ggplot(trinket.data, aes(x = Trinket, y = trinket.CPE)) +
  geom_bar(stat = "identity", color = "black", fill = "gold3") +
  theme(legend.position = "none") +
  xlab("Trinket") + ylab("Coins") +
  labs(title = "Trinket Efficacy (Coins per Life Played)",
  caption = glue("Std. Dev.: {round(tc.sigma, 3)}
                 Red line indicates average across all trinkets.")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  geom_hline(yintercept = mean(trinket.data$trinket.CPE), color = "red")
```

## Top Class-and-Trinket Combos by Lives Played

```{r echo=FALSE}
colnames(ct.rank.sorted) <- c("Combo", "Lives Played")
Rank <- rep(1:nrow(ct.rank.sorted))
ct.rank.sorted <- cbind(Rank, ct.rank.sorted)
print(ct.rank.sorted[c(1:20),], row.names = FALSE)
```

[Click here to return to the main page.](https://maxscampbell.github.io/cgada/)